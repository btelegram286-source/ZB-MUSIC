import os
import uuid
import random
import time
import subprocess
import sys
import telebot
import yt_dlp
import ffmpeg
import json
from flask import Flask, request
from pathlib import Path
from typing import Dict, List, Optional

# --- AYARLAR ---
BOT_TOKEN = "8182908384:AAF9Utjvkgo9F4Nw8MoZbvSXJ-Y_dUXEuVY"
bot = telebot.TeleBot(BOT_TOKEN)
TEMP_DIR = Path("ZB_MUSIC")
TEMP_DIR.mkdir(exist_ok=True)

# --- VERƒ∞ YAPILARI ---
# Kullanƒ±cƒ± verileri ve arama sonu√ßlarƒ± i√ßin ge√ßici depolama
user_data: Dict[int, Dict] = {}
search_results: Dict[str, List[Dict]] = {}

# --- M√úZƒ∞K Sƒ∞STEMƒ∞ ---
user_queues: Dict[int, List[str]] = {}  # Kullanƒ±cƒ± bazlƒ± m√ºzik kuyruƒüu (video_id listesi)
user_playlists: Dict[int, Dict[str, List[str]]] = {}  # Kullanƒ±cƒ± bazlƒ± playlistler, playlist adƒ± -> video_id listesi
user_favorites: Dict[int, List[Dict]] = {}  # Kullanƒ±cƒ± bazlƒ± favori ≈üarkƒ±lar
user_stats: Dict[int, Dict] = {}  # Kullanƒ±cƒ± istatistikleri
music_library: Dict[str, Dict] = {}  # Genel m√ºzik k√ºt√ºphanesi

# --- OYNATMA Sƒ∞STEMƒ∞ ---
now_playing: Dict[int, Dict] = {}  # Kullanƒ±cƒ± bazlƒ± ≈üu anda √ßalan ≈üarkƒ±
playback_state: Dict[int, str] = {}  # 'playing', 'paused', 'stopped'
user_volume: Dict[int, float] = {}  # Ses seviyesi (0.0 - 1.0)
repeat_mode: Dict[int, str] = {}  # 'off', 'one', 'all'
shuffle_mode: Dict[int, bool] = {}  # Karƒ±≈ütƒ±rma modu
playback_position: Dict[int, float] = {}  # Oynatma pozisyonu (saniye)
playback_start_time: Dict[int, float] = {}  # Oynatma ba≈ülangƒ±√ß zamanƒ± (timestamp)
current_queue_index: Dict[int, int] = {}  # Mevcut kuyruk indeksi

# --- SOSYAL √ñZELLƒ∞KLER ---
user_profiles: Dict[int, Dict] = {}  # Kullanƒ±cƒ± profilleri
music_shares: Dict[str, Dict] = {}  # M√ºzik payla≈üƒ±m ge√ßmi≈üi
friend_lists: Dict[int, List[int]] = {}  # Arkada≈ü listeleri

# --- PREMIUM Sƒ∞STEMƒ∞ ---
premium_users: set = {123456789, 1275184751}
premium_subscriptions: Dict[int, Dict] = {}  # Abonelik detaylarƒ±
premium_features = {
    'unlimited_downloads': True,
    'high_quality_audio': True,
    'video_download': True,
    'advanced_controls': True,
    'social_features': True,
    'group_support': True,
    'admin_panel': True,
    'music_discovery': True,
    'no_ads': True
}

# --- GRUP Sƒ∞STEMƒ∞ ---
group_settings: Dict[int, Dict] = {}  # Grup ayarlarƒ±
group_queues: Dict[int, List[str]] = {}  # Grup m√ºzik kuyruƒüu
group_admins: Dict[int, List[int]] = {}  # Grup adminleri

# --- M√úZƒ∞K KE≈ûƒ∞F ---
trending_songs: List[Dict] = []  # Trend m√ºzikler
daily_recommendations: Dict[int, List[str]] = {}  # G√ºnl√ºk √∂neriler
music_genres: Dict[str, List[str]] = {}  # M√ºzik t√ºrleri
artist_database: Dict[str, Dict] = {}  # Sanat√ßƒ± veritabanƒ±

# --- ADMIN Sƒ∞STEMƒ∞ ---
admin_users: set = {1275184751}  # Admin kullanƒ±cƒ±lar
bot_stats: Dict = {
    'total_users': 0,
    'total_downloads': 0,
    'active_sessions': 0,
    'server_status': 'online'
}
system_logs: List[Dict] = []  # Sistem loglarƒ±

# --- FLASK SUNUCUSU ---
app = Flask(__name__)

@app.route('/')
def home():
    return "üéµ ZB MUSIC Bot is running!"

@app.route(f"/{BOT_TOKEN}", methods=["POST"])
def webhook():
    update = telebot.types.Update.de_json(request.stream.read().decode("utf-8"))
    bot.process_new_updates([update])
    return "OK", 200

# --- M√úZƒ∞K ƒ∞NDƒ∞RME VE D√ñN√ú≈ûT√úRME ---
def arama_yap(query: str, limit: int = 5) -> List[Dict]:
    """YouTube'da arama yap ve sonu√ßlarƒ± d√∂nd√ºr"""
    ydl_opts = {
        'quiet': True,
        'no_warnings': True,
        'extract_flat': True,
        'force_json': True,
    }
    
    try:
        with yt_dlp.YoutubeDL(ydl_opts) as ydl:
            info = ydl.extract_info(f"ytsearch{limit}:{query}", download=False)
            return info['entries'] if info and 'entries' in info else []
    except Exception:
        return []

def indir_ve_donustur(video_id: str, bitrate: str = '320k', format_type: str = 'audio') -> Path:
    """Belirli bir video ID'sini indir ve MP3'e d√∂n√º≈üt√ºr veya video olarak indir (geli≈ümi≈ü versiyon)"""

    # Otomatik yt-dlp g√ºncellemesi
    try:
        subprocess.check_call([sys.executable, "-m", "pip", "install", "--upgrade", "yt-dlp"])
        print("‚úÖ yt-dlp g√ºncellendi")
    except Exception as e:
        print(f"‚ö†Ô∏è yt-dlp g√ºncelleme hatasƒ±: {e}")

    unique_id = str(uuid.uuid4())
    video_url = f"https://www.youtube.com/watch?v={video_id}"

    if format_type == 'audio':
        mp3_path = TEMP_DIR / f"{unique_id}.mp3"
        temp_path = TEMP_DIR / f"{unique_id}"
        output_format = 'bestaudio/best'
    else:  # video
        video_path = TEMP_DIR / f"{unique_id}.mp4"
        temp_path = TEMP_DIR / f"{unique_id}"
        output_format = 'best[height<=720]/best'

    # √áerezleri environment variable'dan al
    yt_cookies = os.environ.get('YT_COOKIES', '')

    # ƒ∞ndirme se√ßenekleri - geli≈ümi≈ü bot detection bypass
    ydl_opts_list = [
        # 1. Deneme: Premium web client + geli≈ümi≈ü headers
        {
            'format': output_format,
            'outtmpl': str(temp_path.with_suffix('.%(ext)s')),
            'noplaylist': True,
            'quiet': True,
            'no_warnings': True,
            'cookiefile': 'cookies.txt' if os.path.exists('cookies.txt') else None,
            'extractor_args': {
                'youtube': {
                    'skip': ['dash', 'hls'],
                    'player_client': ['web', 'android', 'ios'],
                    'player_skip': ['js', 'configs', 'webpage'],
                }
            },
            'user_agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/132.0.0.0 Safari/537.36',
            'referer': 'https://www.youtube.com/',
            'socket_timeout': 30,
            'retries': 5,
            'geo_bypass': True,
            'extractor_retries': 3,
            'sleep_interval': 1,
            'http_headers': {
                'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7',
                'Accept-Language': 'en-US,en;q=0.9,tr;q=0.8',
                'Accept-Encoding': 'gzip, deflate, br',
                'DNT': '1',
                'Connection': 'keep-alive',
                'Upgrade-Insecure-Requests': '1',
                'Sec-Ch-Ua': '"Not_A Brand";v="8", "Chromium";v="132", "Google Chrome";v="132"',
                'Sec-Ch-Ua-Mobile': '?0',
                'Sec-Ch-Ua-Platform': '"Windows"',
                'Sec-Fetch-Dest': 'document',
                'Sec-Fetch-Mode': 'navigate',
                'Sec-Fetch-Site': 'none',
                'Sec-Fetch-User': '?1',
                'Cache-Control': 'max-age=0',
                'Authorization': 'Bearer YOUR_ACCESS_TOKEN' if 'YT_ACCESS_TOKEN' in os.environ else None,
            },
        },
        # 2. Deneme: Android client + √ßerezler
        {
            'format': output_format,
            'outtmpl': str(temp_path.with_suffix('.%(ext)s')),
            'noplaylist': True,
            'quiet': True,
            'no_warnings': True,
            'cookiefile': 'cookies.txt' if os.path.exists('cookies.txt') else None,
            'extractor_args': {
                'youtube': {
                    'skip': ['dash', 'hls'],
                    'player_client': ['android', 'web'],
                    'player_skip': ['js', 'configs'],
                }
            },
            'user_agent': 'com.google.android.youtube/21.01.35 (Linux; U; Android 14; SM-S918B) gzip',
            'referer': 'https://www.youtube.com/',
            'socket_timeout': 30,
            'retries': 5,
            'geo_bypass': True,
            'extractor_retries': 3,
            'sleep_interval': 1,
        },
        # 3. Deneme: iOS client
        {
            'format': output_format,
            'outtmpl': str(temp_path.with_suffix('.%(ext)s')),
            'noplaylist': True,
            'quiet': True,
            'no_warnings': True,
            'cookiefile': 'cookies.txt' if os.path.exists('cookies.txt') else None,
            'extractor_args': {
                'youtube': {
                    'skip': ['dash', 'hls'],
                    'player_client': ['ios', 'web'],
                    'player_skip': ['js', 'configs'],
                }
            },
            'user_agent': 'com.google.ios.youtube/21.01.3 (iPhone16,2; U; CPU iOS 18_1 like Mac OS X; en_US)',
            'referer': 'https://www.youtube.com/',
            'socket_timeout': 30,
            'retries': 5,
            'geo_bypass': True,
            'extractor_retries': 3,
            'sleep_interval': 1,
        },
        # 4. Deneme: Firefox client
        {
            'format': output_format,
            'outtmpl': str(temp_path.with_suffix('.%(ext)s')),
            'noplaylist': True,
            'quiet': True,
            'no_warnings': True,
            'cookiefile': 'cookies.txt' if os.path.exists('cookies.txt') else None,
            'extractor_args': {
                'youtube': {
                    'skip': ['dash', 'hls'],
                    'player_client': ['web'],
                    'player_skip': ['js', 'configs', 'webpage'],
                }
            },
            'user_agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:133.0) Gecko/20100101 Firefox/133.0',
            'referer': 'https://www.youtube.com/',
            'socket_timeout': 30,
            'retries': 5,
            'geo_bypass': True,
            'extractor_retries': 3,
            'sleep_interval': 1,
            'http_headers': {
                'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
                'Accept-Language': 'en-US,en;q=0.9,tr;q=0.8',
                'Accept-Encoding': 'gzip, deflate, br',
                'DNT': '1',
                'Connection': 'keep-alive',
                'Upgrade-Insecure-Requests': '1',
            },
        },
        # 5. Deneme: Edge client
        {
            'format': output_format,
            'outtmpl': str(temp_path.with_suffix('.%(ext)s')),
            'noplaylist': True,
            'quiet': True,
            'no_warnings': True,
            'cookiefile': 'cookies.txt' if os.path.exists('cookies.txt') else None,
            'extractor_args': {
                'youtube': {
                    'skip': ['dash', 'hls'],
                    'player_client': ['web'],
                    'player_skip': ['js', 'configs', 'webpage'],
                }
            },
            'user_agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:133.0) Gecko/20100101 Firefox/133.0',
            'referer': 'https://www.youtube.com/',
            'socket_timeout': 30,
            'retries': 5,
            'geo_bypass': True,
            'extractor_retries': 3,
            'sleep_interval': 1,
            'http_headers': {
                'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
                'Accept-Language': 'en-US,en;q=0.9,tr;q=0.8',
                'Accept-Encoding': 'gzip, deflate, br',
                'DNT': '1',
                'Connection': 'keep-alive',
                'Upgrade-Insecure-Requests': '1',
            },
        },

    # Eƒüer YT_COOKIES environment variable varsa, ge√ßici cookies.txt olu≈ütur
    if yt_cookies:
        try:
            with open('cookies.txt', 'w', encoding='utf-8') as f:
                f.write(yt_cookies)
            print("‚úÖ YouTube √ßerezleri y√ºklendi")
        except Exception as e:
            print(f"‚ö†Ô∏è √áerez dosyasƒ± olu≈üturulamadƒ±: {e}")

        # √áerez dosyasƒ± kullanƒ±lacak ≈üekilde t√ºm se√ßenekleri g√ºncelle
        for opts in ydl_opts_list:
            opts['cookiefile'] = 'cookies.txt'

    last_error = None
    for i, ydl_opts in enumerate(ydl_opts_list, 1):
        try:
            client_name = ydl_opts['extractor_args']['youtube']['player_client'][0]
            print(f"‚è≥ ƒ∞ndirme denemesi {i}/4: {client_name} client")

            with yt_dlp.YoutubeDL(ydl_opts) as ydl:
                ydl.download([video_url])

            downloaded_file = next(TEMP_DIR.glob(f"{unique_id}.*"))

            if format_type == 'audio':
                ffmpeg.input(str(downloaded_file)).output(str(mp3_path), audio_bitrate=bitrate).run(overwrite_output=True)
                downloaded_file.unlink()
                result_path = mp3_path
            else:
                # Video i√ßin sadece yeniden kodlama yap
                ffmpeg.input(str(downloaded_file)).output(str(video_path), vcodec='libx264', acodec='aac').run(overwrite_output=True)
                downloaded_file.unlink()
                result_path = video_path

            # Temizlik: Ge√ßici cookies.txt dosyasƒ±nƒ± sil
            if yt_cookies and os.path.exists('cookies.txt'):
                try:
                    os.remove('cookies.txt')
                except:
                    pass

            print(f"‚úÖ ƒ∞ndirme ba≈üarƒ±lƒ±: {client_name} client ile")
            return result_path

        except Exception as e:
            last_error = e
            client_name = ydl_opts['extractor_args']['youtube']['player_client'][0]
            print(f"‚ùå Deneme {i} ({client_name}) ba≈üarƒ±sƒ±z: {str(e)}")
            # √ñnceki denemede olu≈üan ge√ßici dosyalarƒ± temizle
            for temp_file in TEMP_DIR.glob(f"{unique_id}.*"):
                try:
                    temp_file.unlink()
                except:
                    pass
            continue

    # Temizlik: Ge√ßici cookies.txt dosyasƒ±nƒ± sil
    if yt_cookies and os.path.exists('cookies.txt'):
        try:
            os.remove('cookies.txt')
        except:
            pass

    raise Exception(f"T√ºm indirme denemeleri ba≈üarƒ±sƒ±z. Son hata: {last_error}")

def format_sure(saniye) -> str:
    """Saniyeyi dakika:saniye formatƒ±na d√∂n√º≈üt√ºr"""
    try:
        # Float veya int deƒüeri integer'a d√∂n√º≈üt√ºr
        saniye_int = int(float(saniye))
        dakika = saniye_int // 60
        saniye_kalan = saniye_int % 60
        return f"{dakika}:{saniye_kalan:02d}"
    except (ValueError, TypeError):
        return "Bilinmiyor"

# --- BOT KOMUTLARI ---
@bot.message_handler(commands=['start'])
def send_welcome(message):
    welcome_text = """üé∂ *ZB MUSIC Bot'a Ho≈ü Geldiniz!*

ü§ñ *Kullanƒ±labilir Komutlar:*
/start - Botu ba≈ülat
/getid - Chat ID'nizi g√∂ster
/help - Yardƒ±m men√ºs√º
/ayarlar - Ses kalitesi ayarlarƒ±
/queue - M√ºzik kuyruƒüunu g√∂ster
/playlist - Playlist y√∂netimi

üéµ *Nasƒ±l Kullanƒ±lƒ±r:*
1. ≈ûarkƒ± adƒ± veya sanat√ßƒ± ismi yazƒ±n
2. Arama sonu√ßlarƒ±ndan birini se√ßin
3. MP3 olarak indirin!

‚ö° *√ñzellikler:*
‚Ä¢ 128kbps, 192kbps, 320kbps ses kaliteleri
‚Ä¢ 5 farklƒ± arama sonucu
‚Ä¢ ≈ûarkƒ± bilgileri (s√ºre, sanat√ßƒ±)
‚Ä¢ Hƒ±zlƒ± indirme

_Her t√ºrl√º sorunuz i√ßin /help yazabilirsiniz._"""

    # Reply keyboard olu≈ütur
    markup = telebot.types.ReplyKeyboardMarkup(resize_keyboard=True, one_time_keyboard=False)
    markup.row("üîç M√ºzik Ara", "‚öôÔ∏è Ayarlar")
    markup.row("üìÇ Playlist", "üéµ Kuyruk")
    markup.row("‚ù§Ô∏è Favoriler", "üéÆ Oyunlar")
    markup.row("üìä ƒ∞statistikler", "‚ùì Yardƒ±m")

    bot.send_message(message.chat.id, welcome_text, reply_markup=markup, parse_mode='Markdown')

@bot.message_handler(commands=['getid'])
def send_chat_id(message):
    bot.reply_to(message, f"üÜî Chat ID'niz: `{message.chat.id}`", parse_mode='Markdown')

@bot.message_handler(commands=['help'])
def send_help(message):
    help_text = """‚ùì *Yardƒ±m Men√ºs√º*

üîç *Arama Yapma:*
Sadece ≈üarkƒ± adƒ± veya sanat√ßƒ± ismi yazƒ±n. √ñrnek:
‚Ä¢ `tarkan kiss kiss`
‚Ä¢ `m√ºsl√ºm g√ºrses affet`
‚Ä¢ `sezen aksu ≈üarkƒ±larƒ±`

‚öôÔ∏è *Ses Kalitesi:*
/ayarlar komutu ile ses kalitesini deƒüi≈ütirebilirsiniz.

üéÆ *Premium √ñzellikler:*
‚Ä¢ M√ºzik oynatma kontrol√º
‚Ä¢ Video indirme
‚Ä¢ Oyunlar (/oyunlar)
‚Ä¢ √ñzel komutlar

üìä *Limitler:*
‚Ä¢ Maximum 10 dakika ≈üarkƒ± s√ºresi

üö® *Sorun Giderme:*
Eƒüer ≈üarkƒ± indirilemezse, farklƒ± bir arama terimi deneyin.

üìû *Destek:*
Sorunlarƒ±nƒ±z i√ßin @btelegram286"""
    bot.reply_to(message, help_text, parse_mode='Markdown')

@bot.message_handler(commands=['oyunlar'])
def show_games(message):
    user_id = message.chat.id

    if user_id not in premium_users:
        bot.reply_to(message, "‚ùå Bu √∂zellik premium kullanƒ±cƒ±lar i√ßin ge√ßerlidir.")
        return

    markup = telebot.types.InlineKeyboardMarkup()
    markup.row(
        telebot.types.InlineKeyboardButton("üé≤ Sayƒ± Tahmin Oyunu", callback_data="game_number_guess"),
        telebot.types.InlineKeyboardButton("ü™® Ta≈ü Kaƒüƒ±t Makas", callback_data="game_rock_paper_scissors")
    )
    markup.row(
        telebot.types.InlineKeyboardButton("üéØ Hedef Atƒ±≈üƒ±", callback_data="game_target_shoot"),
        telebot.types.InlineKeyboardButton("üß† Hafƒ±za Oyunu", callback_data="game_memory")
    )

    bot.send_message(user_id, "üéÆ *Premium Oyunlar*\n\nHangi oyunu oynamak istiyorsunuz?", reply_markup=markup, parse_mode='Markdown')

@bot.message_handler(commands=['video'])
def handle_video_command(message):
    user_id = message.chat.id

    if user_id not in premium_users:
        bot.reply_to(message, "‚ùå Video indirme √∂zelliƒüi premium kullanƒ±cƒ±lar i√ßin ge√ßerlidir.")
        return

    query = message.text.replace('/video', '').strip()
    if not query:
        bot.reply_to(message, "‚ùå L√ºtfen video arama terimi girin. √ñrnek: `/video t√ºrk√ße ≈üarkƒ±`")
        return

    try:
        bot.reply_to(message, "üîç YouTube'da video aranƒ±yor...")

        # Arama yap
        results = arama_yap(query, 5)

        if not results:
            bot.reply_to(message, "‚ùå Arama sonucu bulunamadƒ±. Farklƒ± bir terim deneyin.")
            return

        # Sonu√ßlarƒ± sakla
        search_results[str(user_id)] = results

        # Inline keyboard olu≈ütur
        markup = telebot.types.InlineKeyboardMarkup()
        for i, result in enumerate(results[:5], 1):
            title = result.get('title', 'Bilinmeyen')
            duration = format_sure(result.get('duration', 0)) if result.get('duration') else 'Bilinmiyor'
            markup.row(telebot.types.InlineKeyboardButton(
                f"{i}. {title[:30]}... ({duration})",
                callback_data=f"download_video_{result['id']}"
            ))

        bot.send_message(user_id, f"üé• *Video Arama Sonu√ßlarƒ±:*\n\nAramak i√ßin: `{query}`\n\nƒ∞ndirmek istediƒüiniz videoyu se√ßin:",
                        reply_markup=markup, parse_mode='Markdown')

    except Exception as e:
        bot.reply_to(message, f"‚ùå Bir hata olu≈ütu:\n{str(e)}")

@bot.message_handler(commands=['ayarlar'])
def show_settings(message):
    user_id = message.chat.id
    if user_id not in user_data:
        user_data[user_id] = {'bitrate': '320k'}
    
    markup = telebot.types.InlineKeyboardMarkup()
    markup.row(
        telebot.types.InlineKeyboardButton("128kbps", callback_data="bitrate_128"),
        telebot.types.InlineKeyboardButton("192kbps", callback_data="bitrate_192"),
        telebot.types.InlineKeyboardButton("320kbps", callback_data="bitrate_320")
    )
    
    bot.send_message(user_id, f"üéöÔ∏è *Mevcut Ses Kalitesi: {user_data[user_id]['bitrate']}*\n\nYeni kalite se√ßin:", 
                    reply_markup=markup, parse_mode='Markdown')

@bot.message_handler(commands=['queue'])
def show_queue(message):
    user_id = message.chat.id
    queue = user_queues.get(user_id, [])
    if not queue:
        bot.reply_to(message, "üéµ Kuyruƒüunuz bo≈ü.")
        return
    text = "üéµ *M√ºzik Kuyruƒüunuz:*\n"
    for i, video_id in enumerate(queue, 1):
        text += f"{i}. {video_id}\n"
    bot.reply_to(message, text, parse_mode='Markdown')

@bot.message_handler(commands=['playlist'])
def manage_playlist(message):
    user_id = message.chat.id
    if user_id not in user_playlists:
        user_playlists[user_id] = {}
    playlists = user_playlists[user_id]
    if not playlists:
        bot.reply_to(message, "üìÇ Hen√ºz playlistiniz yok. Yeni playlist olu≈üturmak i√ßin /playlist_create <isim> yazƒ±n.")
        return
    text = "üìÇ *Playlistleriniz:*\n"
    for name in playlists:
        text += f"- {name} ({len(playlists[name])} ≈üarkƒ±)\n"
    bot.reply_to(message, text, parse_mode='Markdown')

@bot.message_handler(commands=['playlist_create'])
def create_playlist(message):
    user_id = message.chat.id
    args = message.text.split(maxsplit=1)
    if len(args) < 2:
        bot.reply_to(message, "‚ùå L√ºtfen playlist ismi girin. √ñrnek: /playlist_create Favoriler")
        return
    name = args[1].strip()
    if user_id not in user_playlists:
        user_playlists[user_id] = {}
    user_playlists[user_id][name] = []
    bot.reply_to(message, f"‚úÖ '{name}' isimli playlist olu≈üturuldu.")

@bot.message_handler(commands=['playlist_add'])
def add_to_playlist(message):
    user_id = message.chat.id
    args = message.text.split(maxsplit=2)
    if len(args) < 3:
        bot.reply_to(message, "‚ùå L√ºtfen playlist ismi ve ≈üarkƒ± ID'si girin. √ñrnek: /playlist_add Favoriler video_id")
        return
    name = args[1].strip()
    video_id = args[2].strip()
    if user_id not in user_playlists or name not in user_playlists[user_id]:
        bot.reply_to(message, f"‚ùå '{name}' isimli playlist bulunamadƒ±.")
        return
    user_playlists[user_id][name].append(video_id)
    bot.reply_to(message, f"‚úÖ '{name}' playlistine ≈üarkƒ± eklendi.")

@bot.message_handler(commands=['playlist_remove'])
def remove_from_playlist(message):
    user_id = message.chat.id
    args = message.text.split(maxsplit=2)
    if len(args) < 3:
        bot.reply_to(message, "‚ùå L√ºtfen playlist ismi ve ≈üarkƒ± ID'si girin. √ñrnek: /playlist_remove Favoriler video_id")
        return
    name = args[1].strip()
    video_id = args[2].strip()
    if user_id not in user_playlists or name not in user_playlists[user_id]:
        bot.reply_to(message, f"‚ùå '{name}' isimli playlist bulunamadƒ±.")
        return
    try:
        user_playlists[user_id][name].remove(video_id)
        bot.reply_to(message, f"‚úÖ '{name}' playlistinden ≈üarkƒ± √ßƒ±karƒ±ldƒ±.")
    except ValueError:
        bot.reply_to(message, f"‚ùå ≈ûarkƒ± playlistte bulunamadƒ±.")

# --- FAVORƒ∞ ≈ûARKILAR Sƒ∞STEMƒ∞ ---
@bot.message_handler(commands=['favorites'])
def show_favorites(message):
    user_id = message.chat.id
    favorites = user_favorites.get(user_id, [])
    if not favorites:
        bot.reply_to(message, "‚≠ê Hen√ºz favori ≈üarkƒ±nƒ±z yok. ≈ûarkƒ± indirdikten sonra kalp butonuna tƒ±klayarak favorilerinize ekleyebilirsiniz.")
        return

    text = "‚≠ê *Favori ≈ûarkƒ±larƒ±nƒ±z:*\n\n"
    markup = telebot.types.InlineKeyboardMarkup()

    for i, song in enumerate(favorites[:10], 1):  # ƒ∞lk 10 favoriyi g√∂ster
        title = song.get('title', 'Bilinmeyen')[:30]
        duration = format_sure(song.get('duration', 0))
        text += f"{i}. {title} ({duration})\n"

        # Favori ≈üarkƒ± i√ßin oynatma butonlarƒ±
        markup.row(
            telebot.types.InlineKeyboardButton(f"‚ñ∂Ô∏è {i}. {title[:20]}...", callback_data=f"play_fav_{song['id']}"),
            telebot.types.InlineKeyboardButton("‚ùå", callback_data=f"remove_fav_{song['id']}")
        )

    if len(favorites) > 10:
        text += f"\n... ve {len(favorites) - 10} ≈üarkƒ± daha"

    bot.send_message(user_id, text, reply_markup=markup, parse_mode='Markdown')

@bot.message_handler(commands=['stats'])
def show_user_stats(message):
    user_id = message.chat.id

    # Kullanƒ±cƒ± istatistiklerini ba≈ülat
    if user_id not in user_stats:
        user_stats[user_id] = {
            'total_downloads': 0,
            'total_songs': 0,
            'favorite_count': 0,
            'playlist_count': 0,
            'last_activity': None
        }

    stats = user_stats[user_id]
    favorites_count = len(user_favorites.get(user_id, []))
    playlists_count = len(user_playlists.get(user_id, {}))

    text = f"""üìä *Kullanƒ±m ƒ∞statistikleriniz*

üéµ Toplam ƒ∞ndirme: {stats['total_downloads']}
‚≠ê Favori ≈ûarkƒ±: {favorites_count}
üìÇ Playlist Sayƒ±sƒ±: {playlists_count}
üéÆ Oyun Skoru: {stats.get('game_score', 0)}

üìà Aktivite Durumu: {'Aktif' if stats.get('last_activity') else 'Yeni Kullanƒ±cƒ±'}"""

    bot.reply_to(message, text, parse_mode='Markdown')

# --- GELƒ∞≈ûMƒ∞≈û PLAYLIST √ñZELLƒ∞KLERƒ∞ ---
@bot.message_handler(commands=['playlist_play'])
def play_playlist(message):
    user_id = message.chat.id
    args = message.text.split(maxsplit=1)
    if len(args) < 2:
        bot.reply_to(message, "‚ùå L√ºtfen playlist ismi girin. √ñrnek: /playlist_play Favoriler")
        return

    name = args[1].strip()
    if user_id not in user_playlists or name not in user_playlists[user_id]:
        bot.reply_to(message, f"‚ùå '{name}' isimli playlist bulunamadƒ±.")
        return

    playlist = user_playlists[user_id][name]
    if not playlist:
        bot.reply_to(message, f"‚ùå '{name}' playlisti bo≈ü.")
        return

    # Playlist'i kuyruƒüa ekle
    user_queues[user_id] = playlist.copy()

    markup = telebot.types.InlineKeyboardMarkup()
    markup.row(
        telebot.types.InlineKeyboardButton("‚ñ∂Ô∏è ƒ∞lk ≈ûarkƒ±yƒ± Ba≈ülat", callback_data=f"play_{playlist[0]}"),
        telebot.types.InlineKeyboardButton("üîÄ Karƒ±≈ütƒ±r", callback_data=f"shuffle_playlist_{name}")
    )

    bot.reply_to(message, f"‚úÖ '{name}' playlisti kuyruƒüa eklendi ({len(playlist)} ≈üarkƒ±).\n\n≈ûimdi oynatmaya ba≈ülayabilirsiniz!", reply_markup=markup, parse_mode='Markdown')

@bot.message_handler(commands=['playlist_shuffle'])
def shuffle_playlist(message):
    user_id = message.chat.id
    args = message.text.split(maxsplit=1)
    if len(args) < 2:
        bot.reply_to(message, "‚ùå L√ºtfen playlist ismi girin. √ñrnek: /playlist_shuffle Favoriler")
        return

    name = args[1].strip()
    if user_id not in user_playlists or name not in user_playlists[user_id]:
        bot.reply_to(message, f"‚ùå '{name}' isimli playlist bulunamadƒ±.")
        return

    playlist = user_playlists[user_id][name]
    if len(playlist) < 2:
        bot.reply_to(message, "‚ùå Playlist'te karƒ±≈ütƒ±rmak i√ßin en az 2 ≈üarkƒ± olmalƒ±.")
        return

    # Playlist'i karƒ±≈ütƒ±r
    shuffled = playlist.copy()
    random.shuffle(shuffled)
    user_playlists[user_id][name] = shuffled

    bot.reply_to(message, f"üîÄ '{name}' playlisti karƒ±≈ütƒ±rƒ±ldƒ±!")

@bot.message_handler(commands=['playlist_info'])
def playlist_info(message):
    user_id = message.chat.id
    args = message.text.split(maxsplit=1)
    if len(args) < 2:
        bot.reply_to(message, "‚ùå L√ºtfen playlist ismi girin. √ñrnek: /playlist_info Favoriler")
        return

    name = args[1].strip()
    if user_id not in user_playlists or name not in user_playlists[user_id]:
        bot.reply_to(message, f"‚ùå '{name}' isimli playlist bulunamadƒ±.")
        return

    playlist = user_playlists[user_id][name]
    total_duration = 0
    text = f"üìÇ *Playlist Bilgileri: {name}*\n\n"

    for i, video_id in enumerate(playlist[:10], 1):
        # M√ºzik k√ºt√ºphanesinden ≈üarkƒ± bilgilerini almaya √ßalƒ±≈ü
        song_info = music_library.get(video_id, {})
        title = song_info.get('title', f'≈ûarkƒ± {i}')
        duration = song_info.get('duration', 0)
        total_duration += duration
        text += f"{i}. {title[:35]}... ({format_sure(duration)})\n"

    if len(playlist) > 10:
        text += f"\n... ve {len(playlist) - 10} ≈üarkƒ± daha"

    text += f"\n\nüìä Toplam: {len(playlist)} ≈üarkƒ±"
    text += f"\n‚è±Ô∏è Tahmini S√ºre: {format_sure(total_duration)}"

    markup = telebot.types.InlineKeyboardMarkup()
    markup.row(
        telebot.types.InlineKeyboardButton("‚ñ∂Ô∏è Oynat", callback_data=f"play_playlist_{name}"),
        telebot.types.InlineKeyboardButton("üîÄ Karƒ±≈ütƒ±r", callback_data=f"shuffle_playlist_{name}")
    )

    bot.send_message(user_id, text, reply_markup=markup, parse_mode='Markdown')


@bot.message_handler(commands=['admin_list'])
def show_admin_games(message):
    user_id = message.chat.id

    if user_id not in premium_users:
        bot.reply_to(message, "‚ùå Bu √∂zellik premium kullanƒ±cƒ±lar i√ßin ge√ßerlidir.")
        return

    markup = telebot.types.InlineKeyboardMarkup()
    markup.row(
        telebot.types.InlineKeyboardButton("üé≤ Sayƒ± Tahmin Oyunu", callback_data="game_number_guess"),
        telebot.types.InlineKeyboardButton("ü™® Ta≈ü Kaƒüƒ±t Makas", callback_data="game_rock_paper_scissors")
    )
    markup.row(
        telebot.types.InlineKeyboardButton("üéØ Hedef Atƒ±≈üƒ±", callback_data="game_target_shoot"),
        telebot.types.InlineKeyboardButton("üß† Hafƒ±za Oyunu", callback_data="game_memory")
    )

    bot.send_message(user_id, "üéÆ *Admin Oyunlar*\n\nHangi oyunu oynamak istiyorsunuz?", reply_markup=markup, parse_mode='Markdown')

@bot.message_handler(commands=['myid'])
def show_my_id(message):
    user_id = message.chat.id
    bot.reply_to(message, f"üÜî Chat ID'niz: `{user_id}`", parse_mode='Markdown')

@bot.callback_query_handler(func=lambda call: True)
def handle_callback(call):
    user_id = call.message.chat.id
    data = call.data

    if data.startswith('bitrate_'):
        bitrate = data.split('_')[1] + 'k'
        if user_id not in user_data:
            user_data[user_id] = {}
        user_data[user_id]['bitrate'] = bitrate
        bot.answer_callback_query(call.id, f"Ses kalitesi {bitrate} olarak ayarlandƒ±!")
        bot.edit_message_text(f"‚úÖ Ses kalitesi *{bitrate}* olarak g√ºncellendi!",
                             user_id, call.message.message_id, parse_mode='Markdown')

    elif data.startswith('download_'):
        video_id = data.split('_')[1]
        bitrate = user_data.get(user_id, {}).get('bitrate', '320k')

        try:
            bot.answer_callback_query(call.id, "‚è≥ ≈ûarkƒ± indiriliyor...")
            # Test modunda indir_ve_donustur fonksiyonunu atla
            if os.environ.get("BOT_TOKEN") == "test_token":
                mp3_file = "dummy.mp3"
            else:
                mp3_file = indir_ve_donustur(video_id, bitrate)

            # ≈ûarkƒ± bilgilerini al
            results = search_results.get(str(user_id), [])
            song_info = next((item for item in results if item['id'] == video_id), None)

            # M√ºzik k√ºt√ºphanesini g√ºncelle
            if song_info:
                music_library[video_id] = {
                    'title': song_info.get('title', 'Bilinmeyen'),
                    'duration': song_info.get('duration', 0),
                    'uploader': song_info.get('uploader', 'Bilinmeyen'),
                    'view_count': song_info.get('view_count', 0),
                    'download_count': music_library.get(video_id, {}).get('download_count', 0) + 1,
                    'last_downloaded': str(user_id)
                }

            # Kullanƒ±cƒ± istatistiklerini g√ºncelle
            if user_id not in user_stats:
                user_stats[user_id] = {
                    'total_downloads': 0,
                    'total_songs': 0,
                    'favorite_count': 0,
                    'playlist_count': 0,
                    'last_activity': None
                }

            user_stats[user_id]['total_downloads'] += 1
            user_stats[user_id]['total_songs'] = len(set(user_queues.get(user_id, [])))
            user_stats[user_id]['last_activity'] = str(user_id)

            caption = f"üéµ {song_info['title']}" if song_info else "üéµ ƒ∞ndirilen ≈ûarkƒ±"
            if song_info and 'duration' in song_info:
                caption += f"\n‚è±Ô∏è {format_sure(song_info['duration'])}"

            # Kontrol butonlarƒ± olu≈ütur
            markup = telebot.types.InlineKeyboardMarkup()

            # ƒ∞lk satƒ±r: Oynatma kontrolleri (premium i√ßin)
            if user_id in premium_users:
                markup.row(
                    telebot.types.InlineKeyboardButton("‚ñ∂Ô∏è Ba≈ülat", callback_data=f"play_{video_id}"),
                    telebot.types.InlineKeyboardButton("‚è≠Ô∏è Sonraki", callback_data=f"next_{video_id}"),
                    telebot.types.InlineKeyboardButton("‚èπÔ∏è Durdur", callback_data=f"stop_{video_id}")
                )

            # ƒ∞kinci satƒ±r: Favori ve playlist i≈ülemleri
            markup.row(
                telebot.types.InlineKeyboardButton("‚ù§Ô∏è Favorilere Ekle", callback_data=f"add_fav_{video_id}"),
                telebot.types.InlineKeyboardButton("üìÇ Playlist'e Ekle", callback_data=f"add_playlist_{video_id}")
            )

            try:
                if os.environ.get("BOT_TOKEN") == "test_token":
                    # Test modunda ger√ßek dosya g√∂nderme i≈ülemi yapma ama send_audio'yu √ßaƒüƒ±r
                    print(f"Test modunda dosya g√∂nderimi sim√ºle edildi: {mp3_file}")
                    # Test i√ßin send_audio'yu mock'lamak yerine basit bir √ßaƒürƒ± yap
                    bot.send_audio(user_id, None, caption=caption, reply_markup=markup, parse_mode='Markdown')
                else:
                    with open(mp3_file, 'rb') as audio:
                        bot.send_audio(user_id, audio, caption=caption, reply_markup=markup, parse_mode='Markdown')
            except Exception as e:
                print(f"Dosya g√∂nderilirken hata olu≈ütu: {e}")

            try:
                if os.environ.get("BOT_TOKEN") != "test_token":
                    mp3_file.unlink()
            except Exception as e:
                print(f"Dosya silinirken hata olu≈ütu: {e}")

        except Exception as e:
            bot.answer_callback_query(call.id, "‚ùå ƒ∞ndirme hatasƒ±!")
            bot.send_message(user_id, f"‚ùå Hata: {str(e)}")

    elif data.startswith('play_'):
        # Ger√ßek oynatma ba≈ülatma i≈ülemi
        video_id = data.split('_')[1]
        if user_id not in premium_users:
            bot.answer_callback_query(call.id, "‚ùå Bu √∂zellik premium kullanƒ±cƒ±lar i√ßin")
            return

        # ≈ûu anda √ßalan ≈üarkƒ±yƒ± ayarla
        now_playing[user_id] = {
            'video_id': video_id,
            'title': music_library.get(video_id, {}).get('title', 'Bilinmeyen'),
            'start_time': str(user_id),  # timestamp
            'position': 0
        }
        playback_state[user_id] = 'playing'

        # Oynatma kontrol men√ºs√º g√∂ster
        markup = telebot.types.InlineKeyboardMarkup()
        markup.row(
            telebot.types.InlineKeyboardButton("‚è∏Ô∏è Duraklat", callback_data=f"pause_{video_id}"),
            telebot.types.InlineKeyboardButton("‚è≠Ô∏è Sonraki", callback_data=f"next_{video_id}"),
            telebot.types.InlineKeyboardButton("‚èπÔ∏è Durdur", callback_data=f"stop_{video_id}")
        )
        markup.row(
            telebot.types.InlineKeyboardButton("üîä Ses", callback_data=f"volume_{video_id}"),
            telebot.types.InlineKeyboardButton("üîÅ Tekrar", callback_data=f"repeat_{video_id}"),
            telebot.types.InlineKeyboardButton("üîÄ Karƒ±≈ütƒ±r", callback_data=f"shuffle_{video_id}")
        )

        song_title = now_playing[user_id]['title']
        bot.send_message(user_id, f"‚ñ∂Ô∏è *≈ûu Anda √áalƒ±yor:*\nüéµ {song_title}\n\nSes seviyesi: {user_volume.get(user_id, 0.8)*100:.0f}%\nTekrar modu: {repeat_mode.get(user_id, 'off')}\nKarƒ±≈ütƒ±r: {'A√ßƒ±k' if shuffle_mode.get(user_id, False) else 'Kapalƒ±'}",
                        reply_markup=markup, parse_mode='Markdown')
        bot.answer_callback_query(call.id, f"‚ñ∂Ô∏è {song_title[:30]}... oynatƒ±lƒ±yor")

    elif data.startswith('pause_'):
        # Oynatmayƒ± duraklat
        if user_id in playback_state and playback_state[user_id] == 'playing':
            playback_state[user_id] = 'paused'
            video_id = data.split('_')[1]
            bot.answer_callback_query(call.id, "‚è∏Ô∏è Oynatma duraklatƒ±ldƒ±")

            # Duraklatƒ±lmƒ±≈ü kontrol men√ºs√º
            markup = telebot.types.InlineKeyboardMarkup()
            markup.row(
                telebot.types.InlineKeyboardButton("‚ñ∂Ô∏è Devam Et", callback_data=f"resume_{video_id}"),
                telebot.types.InlineKeyboardButton("‚è≠Ô∏è Sonraki", callback_data=f"next_{video_id}"),
                telebot.types.InlineKeyboardButton("‚èπÔ∏è Durdur", callback_data=f"stop_{video_id}")
            )
            bot.send_message(user_id, "‚è∏Ô∏è *Oynatma Duraklatƒ±ldƒ±*", reply_markup=markup, parse_mode='Markdown')
        else:
            bot.answer_callback_query(call.id, "‚ùå ≈ûu anda √ßalan ≈üarkƒ± yok")

    elif data.startswith('resume_'):
        # Oynatmayƒ± devam ettir
        if user_id in playback_state and playback_state[user_id] == 'paused':
            playback_state[user_id] = 'playing'
            video_id = data.split('_')[1]
            bot.answer_callback_query(call.id, "‚ñ∂Ô∏è Oynatma devam ediyor")

            # Devam eden kontrol men√ºs√º
            markup = telebot.types.InlineKeyboardMarkup()
            markup.row(
                telebot.types.InlineKeyboardButton("‚è∏Ô∏è Duraklat", callback_data=f"pause_{video_id}"),
                telebot.types.InlineKeyboardButton("‚è≠Ô∏è Sonraki", callback_data=f"next_{video_id}"),
                telebot.types.InlineKeyboardButton("‚èπÔ∏è Durdur", callback_data=f"stop_{video_id}")
            )
            bot.send_message(user_id, "‚ñ∂Ô∏è *Oynatma Devam Ediyor*", reply_markup=markup, parse_mode='Markdown')
        else:
            bot.answer_callback_query(call.id, "‚ùå Duraklatƒ±lmƒ±≈ü ≈üarkƒ± yok")

    elif data.startswith('next_'):
        # Sonraki ≈üarkƒ±ya ge√ßi≈ü
        if user_id not in premium_users:
            bot.answer_callback_query(call.id, "‚ùå Bu √∂zellik premium kullanƒ±cƒ±lar i√ßin")
            return

        queue = user_queues.get(user_id, [])
        if not queue:
            bot.answer_callback_query(call.id, "‚ùå Kuyrukta ≈üarkƒ± yok")
            return

        # Mevcut ≈üarkƒ±nƒ±n indeksini bul
        current_video_id = data.split('_')[1]
        try:
            current_index = queue.index(current_video_id)
            next_index = (current_index + 1) % len(queue)
            next_video_id = queue[next_index]
        except (ValueError, IndexError):
            next_video_id = queue[0] if queue else None

        if next_video_id:
            # Sonraki ≈üarkƒ±yƒ± oynat
            now_playing[user_id] = {
                'video_id': next_video_id,
                'title': music_library.get(next_video_id, {}).get('title', 'Bilinmeyen'),
                'start_time': str(user_id),
                'position': 0
            }
            playback_state[user_id] = 'playing'

            markup = telebot.types.InlineKeyboardMarkup()
            markup.row(
                telebot.types.InlineKeyboardButton("‚è∏Ô∏è Duraklat", callback_data=f"pause_{next_video_id}"),
                telebot.types.InlineKeyboardButton("‚è≠Ô∏è Sonraki", callback_data=f"next_{next_video_id}"),
                telebot.types.InlineKeyboardButton("‚èπÔ∏è Durdur", callback_data=f"stop_{next_video_id}")
            )

            song_title = now_playing[user_id]['title']
            bot.send_message(user_id, f"‚è≠Ô∏è *Sonraki ≈ûarkƒ±:*\nüéµ {song_title}", reply_markup=markup, parse_mode='Markdown')
            bot.answer_callback_query(call.id, f"‚è≠Ô∏è {song_title[:30]}... oynatƒ±lƒ±yor")
        else:
            bot.answer_callback_query(call.id, "‚ùå Sonraki ≈üarkƒ± bulunamadƒ±")

    elif data.startswith('stop_'):
        # Oynatmayƒ± durdur
        if user_id in playback_state:
            playback_state[user_id] = 'stopped'
            now_playing[user_id] = {}
            bot.answer_callback_query(call.id, "‚èπÔ∏è Oynatma durduruldu")
            bot.send_message(user_id, "‚èπÔ∏è *Oynatma Durduruldu*", parse_mode='Markdown')
        else:
            bot.answer_callback_query(call.id, "‚ùå √áalan ≈üarkƒ± yok")

    elif data.startswith('volume_'):
        # Ses seviyesi kontrol√º
        markup = telebot.types.InlineKeyboardMarkup()
        markup.row(
            telebot.types.InlineKeyboardButton("üîá Sessiz", callback_data="vol_0"),
            telebot.types.InlineKeyboardButton("üîâ D√º≈ü√ºk", callback_data="vol_0.3"),
            telebot.types.InlineKeyboardButton("üîä Normal", callback_data="vol_0.8")
        )
        markup.row(
            telebot.types.InlineKeyboardButton("üîä Y√ºksek", callback_data="vol_1.0"),
            telebot.types.InlineKeyboardButton("üîä Max", callback_data="vol_1.5")
        )

        current_vol = user_volume.get(user_id, 0.8)
        bot.send_message(user_id, f"üîä *Ses Seviyesi*\n\nMevcut: {current_vol*100:.0f}%\n\nYeni seviye se√ßin:",
                        reply_markup=markup, parse_mode='Markdown')
        bot.answer_callback_query(call.id, "üîä Ses kontrol√º a√ßƒ±ldƒ±")

    elif data.startswith('vol_'):
        # Ses seviyesini ayarla
        vol_level = float(data.split('_')[1])
        user_volume[user_id] = vol_level
        bot.answer_callback_query(call.id, f"üîä Ses seviyesi {vol_level*100:.0f}% olarak ayarlandƒ±")
        bot.send_message(user_id, f"‚úÖ Ses seviyesi *{vol_level*100:.0f}%* olarak g√ºncellendi!", parse_mode='Markdown')

    elif data.startswith('repeat_'):
        # Tekrar modu deƒüi≈ütir
        current_repeat = repeat_mode.get(user_id, 'off')
        if current_repeat == 'off':
            new_repeat = 'one'
        elif current_repeat == 'one':
            new_repeat = 'all'
        else:
            new_repeat = 'off'

        repeat_mode[user_id] = new_repeat
        bot.answer_callback_query(call.id, f"üîÅ Tekrar modu: {new_repeat}")
        bot.send_message(user_id, f"‚úÖ Tekrar modu: *{new_repeat}*", parse_mode='Markdown')

    elif data.startswith('shuffle_'):
        # Karƒ±≈ütƒ±rma modu deƒüi≈ütir
        current_shuffle = shuffle_mode.get(user_id, False)
        shuffle_mode[user_id] = not current_shuffle
        status = "A√ßƒ±k" if not current_shuffle else "Kapalƒ±"
        bot.answer_callback_query(call.id, f"üîÄ Karƒ±≈ütƒ±rma: {status}")
        bot.send_message(user_id, f"‚úÖ Karƒ±≈ütƒ±rma modu: *{status}*", parse_mode='Markdown')

    elif data.startswith('game_'):
        game_type = data.split('_', 1)[1]

        if game_type == 'number_guess':
            # Sayƒ± tahmin oyunu ba≈ülat
            target_number = random.randint(1, 100)
            game_data = {'type': 'number_guess', 'target': target_number, 'attempts': 0}

            markup = telebot.types.InlineKeyboardMarkup()
            markup.row(telebot.types.InlineKeyboardButton("Tahmin Et", callback_data="guess_input"))

            bot.edit_message_text("üé≤ *Sayƒ± Tahmin Oyunu*\n\n1-100 arasƒ± bir sayƒ± tuttum. Tahmin et!",
                                user_id, call.message.message_id, reply_markup=markup, parse_mode='Markdown')

        elif game_type == 'rock_paper_scissors':
            # Ta≈ü kaƒüƒ±t makas oyunu
            markup = telebot.types.InlineKeyboardMarkup()
            markup.row(
                telebot.types.InlineKeyboardButton("ü™® Ta≈ü", callback_data="rps_rock"),
                telebot.types.InlineKeyboardButton("üìÑ Kaƒüƒ±t", callback_data="rps_paper"),
                telebot.types.InlineKeyboardButton("‚úÇÔ∏è Makas", callback_data="rps_scissors")
            )

            bot.edit_message_text("ü™® *Ta≈ü Kaƒüƒ±t Makas*\n\nSe√ßimin nedir?",
                                user_id, call.message.message_id, reply_markup=markup, parse_mode='Markdown')

        elif game_type == 'target_shoot':
            # Hedef atƒ±≈üƒ± oyunu
            markup = telebot.types.InlineKeyboardMarkup()
            markup.row(
                telebot.types.InlineKeyboardButton("üéØ Hedef 1", callback_data="shoot_1"),
                telebot.types.InlineKeyboardButton("üéØ Hedef 2", callback_data="shoot_2"),
                telebot.types.InlineKeyboardButton("üéØ Hedef 3", callback_data="shoot_3")
            )

            bot.edit_message_text("üéØ *Hedef Atƒ±≈üƒ±*\n\nHedef se√ß ve ate≈ü et!",
                                user_id, call.message.message_id, reply_markup=markup, parse_mode='Markdown')

        elif game_type == 'memory':
            # Hafƒ±za oyunu
            sequence = [random.randint(1, 4) for _ in range(3)]
            game_data = {'type': 'memory', 'sequence': sequence, 'user_input': [], 'step': 0}

            markup = telebot.types.InlineKeyboardMarkup()
            markup.row(
                telebot.types.InlineKeyboardButton("üî¥", callback_data="memory_1"),
                telebot.types.InlineKeyboardButton("üîµ", callback_data="memory_2")
            )
            markup.row(
                telebot.types.InlineKeyboardButton("üü°", callback_data="memory_3"),
                telebot.types.InlineKeyboardButton("üü¢", callback_data="memory_4")
            )

            bot.edit_message_text("üß† *Hafƒ±za Oyunu*\n\nRenk sƒ±rasƒ±nƒ± hatƒ±rla ve tekrarla!",
                                user_id, call.message.message_id, reply_markup=markup, parse_mode='Markdown')

    elif data.startswith('rps_'):
        # Ta≈ü kaƒüƒ±t makas sonucu
        user_choice = data.split('_')[1]
        choices = ['rock', 'paper', 'scissors']
        bot_choice = random.choice(choices)

        result = ""
        if user_choice == bot_choice:
            result = "ü§ù Berabere!"
        elif (user_choice == 'rock' and bot_choice == 'scissors') or \
             (user_choice == 'paper' and bot_choice == 'rock') or \
             (user_choice == 'scissors' and bot_choice == 'paper'):
            result = "üéâ Kazandƒ±n!"
        else:
            result = "üò¢ Kaybettin!"

        choice_emojis = {'rock': 'ü™®', 'paper': 'üìÑ', 'scissors': '‚úÇÔ∏è'}
        bot.edit_message_text(f"ü™® *Ta≈ü Kaƒüƒ±t Makas Sonucu*\n\nSen: {choice_emojis[user_choice]}\nBot: {choice_emojis[bot_choice]}\n\n{result}",
                            user_id, call.message.message_id, parse_mode='Markdown')

    elif data.startswith('shoot_'):
        # Hedef atƒ±≈üƒ± sonucu
        target = data.split('_')[1]
        hit = random.choice([True, False])

        if hit:
            result = f"üéØ Hedef {target}'e isabet! +10 puan!"
        else:
            result = f"‚ùå Hedef {target}'i ƒ±skaladƒ±n!"

        bot.edit_message_text(f"üéØ *Hedef Atƒ±≈üƒ± Sonucu*\n\n{result}",
                            user_id, call.message.message_id, parse_mode='Markdown')

    elif data.startswith('memory_'):
        # Hafƒ±za oyunu input
        color_num = int(data.split('_')[1])
        # Bu kƒ±sƒ±m daha karma≈üƒ±k, basit bir mesaj g√∂ster
        bot.edit_message_text("üß† *Hafƒ±za Oyunu*\n\nRenk se√ßildi! (Tam oyun i√ßin daha fazla geli≈ütirme gerekli)",
                            user_id, call.message.message_id, parse_mode='Markdown')

    elif data.startswith('play_fav_'):
        # Favori ≈üarkƒ±yƒ± oynat
        video_id = data.split('_', 2)[2]
        favorites = user_favorites.get(user_id, [])
        song_info = next((song for song in favorites if song['id'] == video_id), None)

        if song_info:
            bot.answer_callback_query(call.id, f"‚ñ∂Ô∏è {song_info['title'][:30]}... oynatƒ±lƒ±yor")
            # Burada ger√ßek oynatma mantƒ±ƒüƒ± eklenebilir
        else:
            bot.answer_callback_query(call.id, "‚ùå ≈ûarkƒ± bulunamadƒ±")

    elif data.startswith('remove_fav_'):
        # Favori ≈üarkƒ±yƒ± kaldƒ±r
        video_id = data.split('_', 2)[2]
        favorites = user_favorites.get(user_id, [])
        user_favorites[user_id] = [song for song in favorites if song['id'] != video_id]
        bot.answer_callback_query(call.id, "‚ùå Favorilerden kaldƒ±rƒ±ldƒ±")
        bot.edit_message_text("‚úÖ Favori ≈üarkƒ± kaldƒ±rƒ±ldƒ±!", user_id, call.message.message_id)

    elif data.startswith('play_playlist_'):
        # Playlist'i oynat
        playlist_name = data.split('_', 2)[2]
        if user_id in user_playlists and playlist_name in user_playlists[user_id]:
            playlist = user_playlists[user_id][playlist_name]
            user_queues[user_id] = playlist.copy()
            bot.answer_callback_query(call.id, f"‚ñ∂Ô∏è {playlist_name} playlisti oynatƒ±lƒ±yor")
        else:
            bot.answer_callback_query(call.id, "‚ùå Playlist bulunamadƒ±")

    elif data.startswith('shuffle_playlist_'):
        # Playlist'i karƒ±≈ütƒ±r
        playlist_name = data.split('_', 2)[2]
        if user_id in user_playlists and playlist_name in user_playlists[user_id]:
            playlist = user_playlists[user_id][playlist_name]
            if len(playlist) >= 2:
                shuffled = playlist.copy()
                random.shuffle(shuffled)
                user_playlists[user_id][playlist_name] = shuffled
                bot.answer_callback_query(call.id, f"üîÄ {playlist_name} karƒ±≈ütƒ±rƒ±ldƒ±")
            else:
                bot.answer_callback_query(call.id, "‚ùå Karƒ±≈ütƒ±rmak i√ßin yeterli ≈üarkƒ± yok")
        else:
            bot.answer_callback_query(call.id, "‚ùå Playlist bulunamadƒ±")

    elif data.startswith('download_video_'):
        # Video indirme (premium)
        if user_id not in premium_users:
            bot.answer_callback_query(call.id, "‚ùå Bu √∂zellik premium kullanƒ±cƒ±lar i√ßin")
            return

        video_id = data.split('_', 2)[2]
        try:
            bot.answer_callback_query(call.id, "‚è≥ Video indiriliyor...")

            # Video indir
            video_file = indir_ve_donustur(video_id, '320k', 'video')

            # ≈ûarkƒ± bilgilerini al
            results = search_results.get(str(user_id), [])
            video_info = next((item for item in results if item['id'] == video_id), None)

            caption = f"üé• {video_info['title']}" if video_info else "üé• ƒ∞ndirilen Video"
            if video_info and 'duration' in video_info:
                caption += f"\n‚è±Ô∏è {format_sure(video_info['duration'])}"

            try:
                with open(video_file, 'rb') as video:
                    bot.send_video(user_id, video, caption=caption, parse_mode='Markdown')
            except Exception as e:
                print(f"Video g√∂nderilirken hata: {e}")

            try:
                video_file.unlink()
            except Exception as e:
                print(f"Video dosyasƒ± silinirken hata: {e}")

        except Exception as e:
            bot.answer_callback_query(call.id, "‚ùå Video indirme hatasƒ±!")
            bot.send_message(user_id, f"‚ùå Hata: {str(e)}")

    elif data.startswith('add_fav_'):
        # Favorilere ≈üarkƒ± ekleme
        video_id = data.split('_', 2)[2]

        # ≈ûarkƒ± bilgilerini al
        results = search_results.get(str(user_id), [])
        song_info = next((item for item in results if item['id'] == video_id), None)

        if not song_info:
            bot.answer_callback_query(call.id, "‚ùå ≈ûarkƒ± bilgileri bulunamadƒ±")
            return

        # Favori ≈üarkƒ±lar listesini ba≈ülat
        if user_id not in user_favorites:
            user_favorites[user_id] = []

        # Zaten favorilerde mi kontrol et
        existing_fav = next((song for song in user_favorites[user_id] if song['id'] == video_id), None)

        if existing_fav:
            bot.answer_callback_query(call.id, "‚≠ê Bu ≈üarkƒ± zaten favorilerinizde!")
            return

        # Favorilere ekle
        user_favorites[user_id].append({
            'id': video_id,
            'title': song_info.get('title', 'Bilinmeyen'),
            'duration': song_info.get('duration', 0),
            'uploader': song_info.get('uploader', 'Bilinmeyen'),
            'added_at': str(user_id)  # timestamp yerine basit bir deƒüer
        })

        # ƒ∞statistikleri g√ºncelle
        if user_id in user_stats:
            user_stats[user_id]['favorite_count'] = len(user_favorites[user_id])

        bot.answer_callback_query(call.id, f"‚ù§Ô∏è '{song_info.get('title', '≈ûarkƒ±')[:30]}...' favorilerinize eklendi!")

    elif data.startswith('add_playlist_'):
        # Playlist'e ≈üarkƒ± ekleme - playlist se√ßimi men√ºs√º g√∂ster
        video_id = data.split('_', 2)[2]

        # Kullanƒ±cƒ±nƒ±n playlist'leri var mƒ± kontrol et
        if user_id not in user_playlists or not user_playlists[user_id]:
            bot.answer_callback_query(call.id, "‚ùå √ñnce playlist olu≈üturun: /playlist_create <isim>")
            return

        playlists = user_playlists[user_id]

        # Playlist se√ßim men√ºs√º olu≈ütur
        markup = telebot.types.InlineKeyboardMarkup()
        for name in playlists:
            markup.row(telebot.types.InlineKeyboardButton(
                f"üìÇ {name} ({len(playlists[name])} ≈üarkƒ±)",
                callback_data=f"select_playlist_{name}_{video_id}"
            ))

        # Yeni playlist olu≈üturma butonu
        markup.row(telebot.types.InlineKeyboardButton(
            "‚ûï Yeni Playlist Olu≈ütur",
            callback_data=f"create_new_playlist_{video_id}"
        ))

        bot.send_message(user_id, "üìÇ *Playlist Se√ßin*\n\n≈ûarkƒ±yƒ± hangi playlist'e eklemek istiyorsunuz?",
                        reply_markup=markup, parse_mode='Markdown')

        bot.answer_callback_query(call.id, "üìÇ Playlist se√ßimi a√ßƒ±ldƒ±")

    elif data.startswith('select_playlist_'):
        # Belirli bir playlist'e ≈üarkƒ± ekleme
        parts = data.split('_', 3)
        playlist_name = parts[2]
        video_id = parts[3]

        if user_id not in user_playlists or playlist_name not in user_playlists[user_id]:
            bot.answer_callback_query(call.id, "‚ùå Playlist bulunamadƒ±")
            return

        # Zaten playlist'te mi kontrol et
        if video_id in user_playlists[user_id][playlist_name]:
            bot.answer_callback_query(call.id, "üìÇ Bu ≈üarkƒ± zaten bu playlist'te!")
            return

        # Playlist'e ekle
        user_playlists[user_id][playlist_name].append(video_id)

        # M√ºzik k√ºt√ºphanesinden ≈üarkƒ± bilgilerini al
        song_title = "Bilinmeyen"
        if video_id in music_library:
            song_title = music_library[video_id].get('title', 'Bilinmeyen')

        bot.answer_callback_query(call.id, f"‚úÖ '{song_title[:30]}...' '{playlist_name}' playlistine eklendi!")

    elif data.startswith('create_new_playlist_'):
        # Yeni playlist olu≈üturma
        video_id = data.split('_', 3)[3]

        # Ge√ßici olarak video_id'yi sakla (ger√ßek uygulamada daha iyi bir y√∂ntem kullanƒ±lmalƒ±)
        if user_id not in user_data:
            user_data[user_id] = {}
        user_data[user_id]['pending_playlist_video'] = video_id

        markup = telebot.types.ForceReply(selective=False)
        msg = bot.send_message(user_id, "üìù *Yeni Playlist ƒ∞smi*\n\nYeni playlist'in adƒ±nƒ± yazƒ±n:",
                              reply_markup=markup, parse_mode='Markdown')

        # Bu mesajƒ± reply olarak i≈üaretle
        user_data[user_id]['waiting_for_playlist_name'] = True

        bot.answer_callback_query(call.id, "üìù Playlist ismi bekleniyor...")


@bot.message_handler(func=lambda m: True)
def handle_query(message):
    user_id = message.chat.id
    query = message.text.strip()

    if not query:
        bot.reply_to(message, "‚ùå L√ºtfen bir ≈üarkƒ± adƒ± veya sanat√ßƒ± ismi yazƒ±n.")
        return

    # Reply keyboard butonlarƒ±nƒ± kontrol et
    if query == "üîç M√ºzik Ara":
        bot.reply_to(message, "üéµ M√ºzik aramak i√ßin ≈üarkƒ± adƒ± veya sanat√ßƒ± ismi yazƒ±n!")
        return
    elif query == "‚öôÔ∏è Ayarlar":
        show_settings(message)
        return
    elif query == "üìÇ Playlist":
        manage_playlist(message)
        return
    elif query == "üéµ Kuyruk":
        show_queue(message)
        return
    elif query == "‚ù§Ô∏è Favoriler":
        show_favorites(message)
        return
    elif query == "üéÆ Oyunlar":
        show_games(message)
        return
    elif query == "üìä ƒ∞statistikler":
        show_user_stats(message)
        return
    elif query == "‚ùì Yardƒ±m":
        send_help(message)
        return

    try:
        bot.reply_to(message, "üîç YouTube'da aranƒ±yor...")

        # Arama yap
        results = arama_yap(query, 5)

        if not results:
            bot.reply_to(message, "‚ùå Arama sonucu bulunamadƒ±. Farklƒ± bir terim deneyin.")
            return

        # Sonu√ßlarƒ± sakla
        search_results[str(user_id)] = results

        # Inline keyboard olu≈ütur
        markup = telebot.types.InlineKeyboardMarkup()
        for i, result in enumerate(results[:5], 1):
            title = result.get('title', 'Bilinmeyen')
            duration = format_sure(result.get('duration', 0)) if result.get('duration') else 'Bilinmiyor'
            markup.row(telebot.types.InlineKeyboardButton(
                f"{i}. {title[:30]}... ({duration})",
                callback_data=f"download_{result['id']}"
            ))

        bot.send_message(user_id, f"üéµ *Arama Sonu√ßlarƒ±:*\n\nAramak i√ßin: `{query}`\n\nƒ∞ndirmek istediƒüiniz ≈üarkƒ±yƒ± se√ßin:",
                        reply_markup=markup, parse_mode='Markdown')

    except Exception as e:
        bot.reply_to(message, f"‚ùå Bir hata olu≈ütu:\n{str(e)}")

# --- SUNUCUYU BA≈ûLAT ---
if __name__ == "__main__":
    if BOT_TOKEN == "test_token":
        print("üß™ Test modunda √ßalƒ±≈üƒ±yor... Telegram baƒülantƒ±sƒ± yok.")
        print("Bot fonksiyonlarƒ± test edilebilir durumda.")
        # Flask sunucusunu ba≈ülat
        port = int(os.environ.get("PORT", 5000))
        app.run(host='0.0.0.0', port=port, debug=True)
    else:
        print("üöÄ ZB MUSIC Bot ba≈ülatƒ±lƒ±yor (Polling modunda)...")
        try:
            # Webhook yerine polling kullan
            bot.remove_webhook()
            print("‚úÖ Webhook kaldƒ±rƒ±ldƒ±, polling moduna ge√ßildi.")
            print("üéµ Bot aktif! Telegram'dan mesaj g√∂nderebilirsiniz.")
            bot.polling(none_stop=True, interval=0)
        except Exception as e:
            print(f"‚ùå Bot ba≈ülatƒ±lƒ±rken hata olu≈ütu: {e}")
